<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/ws22_ulg_ds_julia/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/ws22_ulg_ds_julia/libs/highlight/github.min.css">
   
    <script src="/ws22_ulg_ds_julia/libs/clipboard.min.js"></script>
  
  
  <script src="/ws22_ulg_ds_julia/libs/plotly-1_58_5.min.js"></script> 
  <script>
    // This function is used when calling `\fig{...}` See # Using \fig{...} below
    const PlotlyJS_json = async (div, url) => {
      response = await fetch(url); // get file
      fig = await response.json(); // convert it to json
      // Make the plot fit the screen responsively. See the documentation of plotly.js. https://plotly.com/javascript/responsive-fluid-layout/
      if (typeof fig.config === 'undefined') { fig["config"]={} }
      delete fig.layout.width
      delete fig.layout.height
      fig["layout"]["autosize"] = true
      fig["config"]["autosizable"] = true
      fig["config"]["responsive"] = true

      // make it easier to scroll throught the website rather than being blocked by a figure.
      fig.config["scrollZoom"] = false

      // PlotlyJS.savefig by default add the some more attribute to make a static plot.
      // Disable them to make the website fancier.
      delete fig.config.staticPlot
      delete fig.config.displayModeBar
      delete fig.config.doubleClick
      delete fig.config.showTips

      Plotly.newPlot(div, fig);
    };
  </script>
  
  <link rel="stylesheet" href="/ws22_ulg_ds_julia/css/jtd.css">
<link rel="stylesheet" href="/ws22_ulg_ds_julia/css/extras.css">
<link rel="icon" href="/ws22_ulg_ds_julia/assets/favicon.ico">

<style>
  /* #148 wrap long header */
  .franklin-content a.header-anchor,
  .franklin-toc li a
   {
    word-wrap: break-word;
    white-space: normal;
  }
</style>

   <title>Functions</title>  
</head>
<body>                      <!-- closed in foot.html -->
<div class="page-wrap">   <!-- closed in foot.html -->
  <!-- SIDE BAR -->
  <div class="side-bar">
    <div class="header">
      <a href="/ws22_ulg_ds_julia/" class="title">
        Julia
      </a>
    </div>
    <label for="show-menu" class="show-menu">MENU</label>
    <input type="checkbox" id="show-menu" role="button">
    <div class="menu" id="side-menu">
      <ul class="menu-list">
        <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/" class="menu-list-link ">Start</a>
        <li class="menu-list-item active"><a href="/ws22_ulg_ds_julia/pages/introduction/" class="menu-list-link active">Introduction</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/basis_datatypes_and_operations/" class="menu-list-link ">Basic Data Types and Operations</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/matrix_vectors/" class="menu-list-link ">Matrix and Vector Operations</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/conditional_evaluations/" class="menu-list-link ">Conditional evaluations</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/loops/" class="menu-list-link ">Loops</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/functions/" class="menu-list-link active">Functions</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/metaprogramming/" class="menu-list-link ">Metaprogramming</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/performance/" class="menu-list-link ">Performance</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/package_manager/" class="menu-list-link ">Package manager</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/development_workflow/" class="menu-list-link ">Development workflow</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/introduction/useful_packages/"
                    class="menu-list-link ">Useful
                    packages</a>
          </ul>
        <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/data_management/" class="menu-list-link ">Data Management</a>
          <ul class="menu-list-child-list ">
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/data_management/loading_data/" class="menu-list-link ">Loading data</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/data_management/saving_data/" class="menu-list-link ">Saving data</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/data_management/exploratory_da/" class="menu-list-link ">Exploratory Data Analysis</a>
            <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/data_management/datasets/" class="menu-list-link ">Data Sets</a>
          </ul>
          <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/neural_networks/" class="menu-list-link ">Neural Networks</a>
          <li class="menu-list-item "><a href="/ws22_ulg_ds_julia/pages/reporting/" class="menu-list-link ">Reporting</a>
      </ul>
    </div>
    <div class="footer">
      This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target="_blank">Jekyll theme</a>.
    </div>
  </div>
  <!-- CONTENT -->
  <div class="main-content-wrap"> <!-- closed in foot.html -->
    <div class="main-content">    <!-- closed in foot.html -->
      <div class="main-header">
        WS22/23 ULG Data Science
      </div>



<!-- Content appended here (in class franklin-content) -->
<div class="franklin-content"><h1 id="functions"><a href="#functions" class="header-anchor">Functions</a></h1>
<div class="franklin-toc"><ol><li><a href="#syntax">Syntax</a></li><li><a href="#anonymous_functions">Anonymous functions</a></li><li><a href="#call_by_reference">Call by reference</a></li><li><a href="#multiple_dispatch">Multiple dispatch</a></li><li><a href="#element-wise_operations_and_input_specifications">Element-wise operations and input specifications</a></li><li><a href="#parametric_types_for_functions">Parametric types for functions</a></li><li><a href="#constructors">Constructors</a></li></ol></div>
<h2 id="syntax"><a href="#syntax" class="header-anchor">Syntax</a></h2>
<p>To improve the structure and ensure reusability of pieces of our program we can use the <code>function</code> command. We have already used functions when, for example, calling <code>typeof&#40;input&#41;</code>. Other examples of functions that can be found on any common calculators are <code>sin&#40;x&#41;</code> or <code>exp&#40;x&#41;</code>. The syntax to define our own functions is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> foo(input)
    <span class="hljs-comment"># function body that is executed when foo is called</span>

    <span class="hljs-keyword">return</span> output
<span class="hljs-keyword">end</span></code></pre>
<p>So if we want to define a function which prints out and returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(\cos(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> we can write</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos(x)
    result = sin(cos(x))
    println(<span class="hljs-string">&quot;sin(cos(<span class="hljs-variable">$x</span>)) = <span class="hljs-variable">$result</span>&quot;</span>)
    
    <span class="hljs-keyword">return</span> result
<span class="hljs-keyword">end</span></code></pre>
<p>If we wish to specify multiple inputs and outputs we can do so as well:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos(x, y)
    result1 = sin(cos(x))
    result2 = sin(cos(y))
    
    println(<span class="hljs-string">&quot;sin(cos(<span class="hljs-variable">$x</span>)) = <span class="hljs-variable">$result1</span>&quot;</span>)
    println(<span class="hljs-string">&quot;sin(cos(<span class="hljs-variable">$y</span>)) = <span class="hljs-variable">$result2</span>&quot;</span>)
    
    <span class="hljs-keyword">return</span> result1, result2
<span class="hljs-keyword">end</span></code></pre>
<p>We can call a function with multiple outputs via <code>out &#61; foo&#40;input&#41;</code> and access the output at index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> through <code>out&#91;i&#93;</code>. We can also write &#40;assuming two outputs&#41; <code>out1, out2 &#61; foo&#40;input&#41;</code> and <code>out1, _ &#61; foo&#40;input&#41;</code> if we only need one of the outputs. The above functions actually returns a tuple <code>&#40;result1, result2&#41;</code>.</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = <span class="hljs-number">1</span>; y = <span class="hljs-number">1.5</span>;
</span><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> res1, res2 = sincos(x, y)
</span>sin(cos(1)) = 0.5143952585235492
sin(cos(1.5)) = 0.07067822452613834
(0.5143952585235492, 0.07067822452613834)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> res1
</span>0.5143952585235492

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> res = sincos(x, y);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> res[<span class="hljs-number">1</span>]
</span>0.5143952585235492</code></pre>
<p>Note that in julia function names are not constant i.e. it is possible to redefine a function mutliple times and when calling it the most recent version is used. This also holds true for function included in julia itself e.g. <code>sincos</code> already exists and by doing the above one can no longer directly call it.</p>
<p>Let us practice this syntax by revisiting loops:</p>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  For a vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>∈</mo><msup><mi mathvariant="normal">R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">V\in\mathrm{R}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathrm">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> with elements <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">v_1, \ldots, v_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> compute the mean of all the elements in the following fashion.</p>
<ol>
<li><p>Sum over the elements per index and divide by the length of the vector.</p>
</li>
</ol>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m = \frac{1}{n}\sum_{i=1}^n v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
<ol start="2">
<li><p>Transform this loop into a function <code>mymean</code>.</p>
</li>
<li><p>Test against <code>V &#61; rand&#40;100_000&#41;</code> and <code>mymean&#40;V&#41; ≈ mean&#40;V&#41;</code> &#40;use <code>\approx &#43; TAB</code> for ≈&#41; using the <code>Statistics</code> standard library.</p>
</li>
</ol>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  </p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> mymean(V)
    s = zero(eltype(V))

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> eachindex(V)
        s += V[i]
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">return</span> s / length(V)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">using</span> Statistics
V = rand(<span class="hljs-number">100_000</span>)
mymean(V) ≈ mean(V)</code></pre>
<p></div> </div>
<h2 id="anonymous_functions"><a href="#anonymous_functions" class="header-anchor">Anonymous functions</a></h2>
<p>Functions can also be created anonymously, that is, without giving a name. We call these functions <a href="https://docs.julialang.org/en/v1/manual/functions/#man-anonymous-functions"><em>anonymous functions</em></a> and they are especially feasible when we want to use a function as an argument. The following snippet creates an anonymous function that takes one argument <code>x</code> and returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x -&gt; x^<span class="hljs-number">2</span> + <span class="hljs-number">1</span>
</span>#1 (generic function with 1 method)</code></pre>
<p>Unfortunately, this function can not be accessed again, since we do not have a name/variable which could be accessed. But we can apply a value right away and e.g. evaluate this anonymous function for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> (x -&gt; x^<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)(<span class="hljs-number">3</span>)
</span>10</code></pre>
<p>This is not a good application for an anonymous function but there are applications where they are indeed quite helpful. Throughout this workshop, we will occasionally use anonymous functions as function arguments. Let us take a look at the function <a href="https://docs.julialang.org/en/v1/base/collections/#Base.map"><code>map&#40;f, c&#41;</code></a> that allows us to transform a collection &#40;e.g. a vector&#41; <code>c</code> by applying function <code>f</code> to every element. The following example applies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↦</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x \mapsto x^2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.522em;vertical-align:-0.011em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> to every element of the vector <code>&#91;1, 2, 3, 4, 5&#93;</code>:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> map(x -&gt; x^<span class="hljs-number">2</span> + <span class="hljs-number">1</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
</span>5-element Vector{Int64}:
  2
  5
 10
 17
 26</code></pre>
<h2 id="call_by_reference"><a href="#call_by_reference" class="header-anchor">Call by reference</a></h2>
<p>Julia functions do not copy the input but directly operate on the input data. This means that changing values of the input in the function body will also change this data for the function caller. Whenever we define a function which will modify the input, we should indicate this with a <code>&#33;</code> behind the function name:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos!(x)
    x .= sin.(cos.(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<p>Calling this function leads to</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>);
</span><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> println(<span class="hljs-string">&quot;Function value is &quot;</span>, sincos!(x))
</span>Function value is [0.5143952585235492, 0.5143952585235492]

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x
</span>2-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492</code></pre>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Consider two implementations</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos1!(x)
    x .= sin.(cos.(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<p>and</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos2!(x)
    x = sin.(cos.(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<ol>
<li><p>Evaluate both functions with the input <code>x &#61; ones&#40;2&#41;</code>. How does <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> change after calling the function? Explain this behavior. Correct the function names accordingly.</p>
</li>
<li><p>Use the build in function <code>pointer&#40;x&#41;</code> to see how the memory changes and to validate your previous answer.</p>
</li>
<li><p>Write a method which evaluates <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(\cos(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi mathvariant="double-struck">R</mi></mrow><annotation encoding="application/x-tex">x\in\mathbb{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">R</span></span></span></span> is a scalar and stores the result on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is modified for the caller.</p>
</li>
</ol>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  1. The function <code>sincos1&#33;&#40;x&#41;</code> will modify the input:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos1!(x);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x
</span>2-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492</code></pre>
<p>The function <code>sincos2&#33;&#40;x&#41;</code> will not modify the input:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos2!(x);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x
</span>2-element Vector{Float64}:
 1.0
 1.0</code></pre>
<p>The reason for this behavior is that <code>sincos1</code> changes the input as Julia functions work with call-by-reference. I.e., they do not generate a local copy of the input and instead directly work on the same memory that has been used by the caller. This memory is not reallocated due to the use of <code>.&#61;</code>. On the other hand, <code>sincos2</code> allocates new memory, since <code>x &#61; sin.&#40;cos.&#40;x&#41;&#41;</code> will create new memory for <code>x</code> on which the values of <code>sin.&#40;cos.&#40;x&#41;&#41;</code> are stored. Hence, the memory of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> known to the caller is not modified and the original values are preserved. Note that the name <code>sincos2&#33;&#40;x&#41;</code> is hence misleading and the function should be renamed to <code>sincos2&#40;x&#41;</code>.</p>
<ol start="2">
<li><p>We have</p>
</li>
</ol>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos1!(x)
    println(<span class="hljs-string">&quot;Address input: &quot;</span>, pointer(x))
    x .= sin.(cos.(x))
    println(<span class="hljs-string">&quot;Address output: &quot;</span>, pointer(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<p>and</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos2(x)
    println(<span class="hljs-string">&quot;Address input: &quot;</span>, pointer(x))
    x = sin.(cos.(x))
    println(<span class="hljs-string">&quot;Address output: &quot;</span>, pointer(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<p>Then,</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> y = sincos1!(x);
</span>Address input: Ptr{Float64} @0x00007f321c376ac0
Address output: Ptr{Float64} @0x00007f321c376ac0

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> println(<span class="hljs-string">&quot;Address caller: &quot;</span>, pointer(x));
</span>Address caller: Ptr{Float64} @0x00007f32c1e45850

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> y = sincos1!(x);
</span>Address input: Ptr{Float64} @0x00007f32c1e45850
Address output: Ptr{Float64} @0x00007f32c1e45850

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> y = sincos2(x);
</span>Address input: Ptr{Float64} @0x00007f32c1e45850
Address output: Ptr{Float64} @0x00007f32c1e81620</code></pre>
<ol start="3">
<li><p>This is not directly possible, since assigning a new value to a scalar <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> will always alter the memory location.</p>
</li>
</ol>
<p>However using <code>Ref</code> it can be done</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos!(x::<span class="hljs-built_in">Ref</span>{&lt;:<span class="hljs-built_in">Real</span>})
    x[] = sin(cos(x[]))
<span class="hljs-keyword">end</span></code></pre>
<p>and</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = <span class="hljs-built_in">Ref</span>(<span class="hljs-number">1.2</span>)
</span>Base.RefValue{Float64}(1.2)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos!(x)
</span>0.35447986700952583

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x
</span>Base.RefValue{Float64}(0.35447986700952583)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x[]
</span>0.35447986700952583</code></pre>
<p></div> </div>
<h2 id="multiple_dispatch"><a href="#multiple_dispatch" class="header-anchor">Multiple dispatch</a></h2>
<p>One might have observed that since we did not specify any data types, we were able to call functions using vectors and scalars. However, if we call <code>sincos1&#33;&#40;1.0&#41;</code> we see that this might not always be the best idea. Some functions should only be called with a certain data type. We can specify the data type of input and output in the following way:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos1!(x::<span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Float64</span>, <span class="hljs-number">1</span>})
    x .= sin.(cos.(x))

    <span class="hljs-keyword">return</span> x
<span class="hljs-keyword">end</span></code></pre>
<p>In the same way, we can define functions that have the same name but which perform different operations depending on the data type. For example, we can define the function <code>sincos&#40;x&#41;</code> which evaluates <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(\cos(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span> when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is a matrix or vector and returns a vector. In order to rearrange a matrix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span> to a vector <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> we can use <code>m &#61; vec&#40;M&#41;</code>. Then, we get:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos(x::<span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Float64</span>, <span class="hljs-number">1</span>})
    println(<span class="hljs-string">&quot;My input is a vector.&quot;</span>)

    <span class="hljs-keyword">return</span> sin.(cos.(x))
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">function</span> sincos(x::<span class="hljs-built_in">Array</span>{<span class="hljs-built_in">Float64</span>, <span class="hljs-number">2</span>})
    println(<span class="hljs-string">&quot;My input is a matrix.&quot;</span>)

    <span class="hljs-keyword">return</span> vec(sin.(cos.(x)))
<span class="hljs-keyword">end</span></code></pre>
<p>Calling these functions gives</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos(x)
</span>My input is a matrix.
4-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492
 0.5143952585235492
 0.5143952585235492

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">4</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos(x)
</span>My input is a vector.
4-element Vector{Float64}:
 0.5143952585235492
 0.5143952585235492
 0.5143952585235492
 0.5143952585235492</code></pre>
<p>Julia will always use the most specific method for the function arguments during the call. In order to see all available methods for a specific function we can use <code>methods&#40;sincos&#41;</code> or any other function &#40;e.g. <code>&#43;</code>&#41;.</p>
<p>It is also possible to write new method definitions for already existing functions, which is a powerful concept for package development. On the other hand it can also be dangerous as the following example shows</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> Base.sin(x::<span class="hljs-built_in">Float64</span>) = <span class="hljs-string">&quot;Breaking code&quot;</span>
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos([<span class="hljs-number">1.2</span>, <span class="hljs-number">2.</span>])
</span>My input is a vector.
2-element Vector{String}:
 &quot;Breaking code&quot;
 &quot;Breaking code&quot;</code></pre>
<p>Here we explicetly define a new method for the base function <code>Base.sin</code> since doing <code>sin&#40;...</code> would just define a function with the name <code>sin</code>. However this discouraged since both <code>sin</code> and <code>Float64</code> come from base julia and thus we are performing <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">type piracy</a>.</p>
<h2 id="element-wise_operations_and_input_specifications"><a href="#element-wise_operations_and_input_specifications" class="header-anchor">Element-wise operations and input specifications</a></h2>
<p>As seen already, we can use the dot operation <code>.</code> to evaluate an array of inputs element-wise. Define the scalar function</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> sincos(x::<span class="hljs-built_in">Real</span>)
    <span class="hljs-keyword">return</span> sin(cos(x))    
<span class="hljs-keyword">end</span></code></pre>
<p>and run</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> x = ones(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos.(x)
</span>2×3 Matrix{Float64}:
 0.514395  0.514395  0.514395
 0.514395  0.514395  0.514395</code></pre>
<p>Fore more information see the <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting section</a> in the manual.</p>
<p>Moreover, we can assign values to inputs in the function definition. If the caller does not specify the input, these values will be used instead.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> myfun(x::<span class="hljs-built_in">Float64</span>=(<span class="hljs-number">0.5</span> * <span class="hljs-literal">pi</span>))
    <span class="hljs-keyword">return</span> sin(cos(x))
<span class="hljs-keyword">end</span></code></pre>
<p>We can now call this function via</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> myfun()
</span>6.123233995736766e-17

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> myfun(<span class="hljs-number">0.0</span>)
</span>0.8414709848078965</code></pre>
<p>Assigning default values for function arguments defines mutliple methods and is actually short hand for the following</p>
<pre><code class="julia hljs">myfun() = sin(cos(<span class="hljs-number">0.5</span> * <span class="hljs-literal">pi</span>))
myfun(x::<span class="hljs-built_in">Float64</span>) = sin(cos(x))</code></pre>
<h2 id="parametric_types_for_functions"><a href="#parametric_types_for_functions" class="header-anchor">Parametric types for functions</a></h2>
<p>Notice that it is very restrictive to tell our method to only accept inputs of type <code>Float64</code>. It makes perfect sense to evaluate our function at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> can be an integer. In fact, it is considered to be good practice if we make function inputs as general as possible. In fact not setting a type &#40;equivalent to <code>::Any</code>&#41; is also possible. Just as for <em>structs</em>, we can use parametric types to make the input more general. If we want the input to be a real number &#40;i.e., a subtype of <code>Real</code>&#41;, we can write this as </p>
<pre><code class="julia hljs"><span class="hljs-keyword">function</span> myadd(x::T, y::T) <span class="hljs-keyword">where</span> {T&lt;:<span class="hljs-built_in">Real</span>}
    println(<span class="hljs-string">&quot;Got numbers of type <span class="hljs-subst">$(T)</span> as input&quot;</span>)
    <span class="hljs-keyword">return</span> x + y
<span class="hljs-keyword">end</span></code></pre>
<p>Now, <code>T</code> can be any subtype of <code>Real</code>, that is, we can write</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> myadd(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</span>Got numbers of type Int64 as input
3

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> myadd(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)
</span>Got numbers of type Float64 as input
3.0</code></pre>
<button type="button" class="collapsible" style="background-color:#b5ddff"> Exercise </button><div class="collapsiblecontent">  Write a function <code>sincos</code> which can take any real number as well as the point struct we defined earlier</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> Point{T&lt;:<span class="hljs-built_in">Real</span>}
    x::T
    y::T
<span class="hljs-keyword">end</span></code></pre>
<p>as input. When the input is an object of type <code>Point</code>, the function returns <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∥</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sin(\cos(\Vert x \Vert))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mop">cos</span><span class="mopen">(</span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord">∥</span><span class="mclose">))</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∥</mi><mi>x</mi><mi mathvariant="normal">∥</mi><mo>=</mo><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\Vert x \Vert = \sqrt{x^2 + y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∥</span><span class="mord mathnormal">x</span><span class="mord">∥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2822em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9178em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2822em;"><span></span></span></span></span></span></span></span></span> is the Euclidean norm.</p>
<p><div class="solution"> Solution </div><div class="solutioncollapsible">  </p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> Point{T&lt;:<span class="hljs-built_in">Real</span>}
    x::T
    y::T
<span class="hljs-keyword">end</span>

sincos(x::<span class="hljs-built_in">Real</span>) = sin(cos(x))

sincos(point::Point{&lt;:<span class="hljs-built_in">Real</span>}) = sincos(sqrt(point.x^<span class="hljs-number">2</span> + point.y^<span class="hljs-number">2</span>))</code></pre>
<p>Then, we get</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sin(cos(<span class="hljs-number">0</span>)) == sincos(Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))
</span>true

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> sincos(<span class="hljs-number">1.0</span> + <span class="hljs-literal">im</span>)
</span>ERROR: MethodError: no method matching sincos(::ComplexF64)
You may have intended to import Base.sincos
Closest candidates are:
  sincos(::Real) at REPL[2]:1
  sincos(::Point) at REPL[3]:1
Stacktrace:
 [1] top-level scope
   @ REPL[8]:1</code></pre>
<p></div> </div>
<h2 id="constructors"><a href="#constructors" class="header-anchor">Constructors</a></h2>
<p>Note from the previous exercise, that it might be convenient if every object of type <code>Point</code> computes and stores the norm. Of course this can be done by defining</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> PointFull{T&lt;:<span class="hljs-built_in">Real</span>}
    x::T
    y::T
    norm
<span class="hljs-keyword">end</span></code></pre>
<p>and creating objects of type <code>PointFull</code> via</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> p = PointFull(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, sqrt(<span class="hljs-number">1.0</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2.0</span>^<span class="hljs-number">2</span>))
</span>PointFull{Float64}(1.0, 2.0, 2.23606797749979)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> p = PointFull{<span class="hljs-built_in">Float32</span>}(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, sqrt(<span class="hljs-number">1.0</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2.0</span>^<span class="hljs-number">2</span>))
</span>PointFull{Float32}(1.0f0, 2.0f0, 2.23606797749979)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> p = PointFull{<span class="hljs-built_in">Int64</span>}(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, sqrt(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>))
</span>PointFull{Int64}(1, 2, 1.7320508075688772)</code></pre>
<p>Note that this is quite tedious since we need to copy paste the same formula for the norm every time we construct on object. Conveniently, Julia provides us with <a href="https://docs.julialang.org/en/v1/manual/constructors/#man-constructors">constructors</a>, which are functions that are called whenever we create on object of our struct. The syntax is the following:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">struct</span> PointFull1{T&lt;:<span class="hljs-built_in">Real</span>}
    x::T
    y::T
    norm::T

    <span class="hljs-keyword">function</span> PointFull1(x::T1, y::T2) <span class="hljs-keyword">where</span> {T1&lt;:<span class="hljs-built_in">Real</span>,T2&lt;:<span class="hljs-built_in">Real</span>}
        T = promote_type(T1, T2)
        norm = T(sqrt(x^<span class="hljs-number">2</span> + y^<span class="hljs-number">2</span>))
        new{T}(x, y, norm)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre>
<p>Now, we can call</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> PointFull1(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)
</span>PointFull1{Float64}(1.0, 2.0, 2.23606797749979)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> PointFull1(<span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>)
</span>PointFull1{Float64}(1.0, 2.0, 2.23606797749979)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> PointFull1(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>//<span class="hljs-number">4</span>)
</span>PointFull1{Rational{Int64}}(1//1, 3//4, 5//4)

<span class="hljs-meta prompt_">julia&gt;</span><span class="language-julia"> PointFull1(<span class="hljs-number">1</span>, <span class="hljs-number">1.0</span><span class="hljs-literal">im</span>)
</span>ERROR: MethodError: no method matching PointFull1(::Int64, ::ComplexF64)
Closest candidates are:
  PointFull1(::T1, ::T2) where {T1&lt;:Real, T2&lt;:Real} at REPL[10]:6
Stacktrace:
 [1] top-level scope
   @ REPL[16]:1</code></pre>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> - <a href="https://www.uibk.ac.at/mathematik/personal/antholzer/">Stephan Antholzer</a>, <a href="https://ehrensperger.dev/">Gregor Ehrensperger</a>, <a href="https://igs.uibk.ac.at/igs_html/members/IGSMember_Sappl.html">Johannes Sappl</a>. Last modified: January 10, 2023.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    </div> <!-- end of class main-content -->
    </div> <!-- end of class main-content-wrap -->
    </div> <!-- end of class page-wrap-->
    
      



    
    
      


      <script>
    (function(){
    
      // Get the elements.
      // - the 'pre' element.
      // - the 'div' with the 'paste-content' id.
    
      var pre = document.getElementsByTagName('pre');
    
      // Add a copy button in the 'pre' element.
      // which only has the className of 'language-'.
    
      for (var i = 0; i < pre.length; i++) {
        var isLanguage = pre[i].children[0].tagName == 'CODE';
    
        if ( isLanguage ) {
          var button           = document.createElement('button');
              button.className = 'copy-button';
              button.textContent = 'Copy';
    
              pre[i].appendChild(button);
        }
      };
    
      // Run Clipboard
    
      var copyCode = new Clipboard('.copy-button', {
        target: function(trigger) {
          return trigger.previousElementSibling;
        }
      });
    
      // On success:
      // - Change the "Copy" text to "Copied".
      // - Swap it to "Copy" in 2s.
      // - Lead user to the "contenteditable" area with Velocity scroll.
    
      copyCode.on('success', function(event) {
        event.clearSelection();
        event.trigger.textContent = 'Copied';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 2000);
    
      });
    
      // On error (Safari):
      // - Change the  "Press Ctrl+C to copy"
      // - Swap it to "Copy" in 2s.
    
      copyCode.on('error', function(event) {
        event.trigger.textContent = 'Press "Ctrl + C" to copy';
        window.setTimeout(function() {
          event.trigger.textContent = 'Copy';
        }, 5000);
      });
    
    })();
</script>
    
  </body>
</html>

<script>
  var coll = document.getElementsByClassName("collapsible");
  var i;

  for (i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.display === "block") {
        content.style.display = "none";
      } else {
        content.style.display = "block";
      }
    });
  }
</script>

<script>
  var coll = document.getElementsByClassName("solutioncollapsible");
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  const myVar = urlParams.get('solution')
  if ( myVar == 'true') {
    for (i = 0; i < coll.length; i++) {
      coll[i].style.display = "block";
    }
  }
</script>